natural transformations

functions map within categories
functors map between categories
nat trans are mapping between functors

for categories C, D functors F, G with objects a, Fa Ga
we want to consider a transformation between functors F and G
that is
pick a morphism Fa -> Ga, α_a
similarly for b in C we have, Fb -> Gb, α_b
also a->b f, Fa->Fb Ff, Ga->Gb  Gf

for a natural transformation to exist requires a relation between two Functors
Naturality Condition
α_b . Ff = Gf α_a

or that α_b is determined in terms of α_a
α_b = Gf α_a (Ff)⁻¹

natural isomorphism (invertible NT)
all of the components are invertible

we can also say that a NT
maps objects a (in C) to morphisms Fa -> Ga (in D)
or
maps morphisms to commuting diagrams (the nat cond)
for some f, α_b . Ff = Gf α_a 

alpha :: forall a. F a -> G a
with NC
alpha . fmap_F f = fmap_G f . alpha

safeHead :: [a] -> Maybe a
safeHead []   = Nothing
safeHead x:xs = Just x
         
safeHead . fmap f (x:xs) = fmap f . safeHead (x:xs)
proven equivalent optimization
allows us to avoid mapping f on the whole list

so if functors are containers
where fmap modifies the contents without changing the container
then NT, orthogonally
repackages the container where the contents are never modified
e.g.  in safeHead
we are going from [] to Maybe
without any regard to the a within

the NT states it doesn't matter to first change functorial contents
then repackage, or vice versa

Identity is a functor, a->[a] is a NT
Const is a functor, length :: [a]->Const Int a is a NT

in general from ADT to ADT is a NT, because ADT in general are functors
minding contravariant bifunctors etc
which require the equivalent generalizations of NTs

i.e.
consider a->a (or (->) a a)
which would be both covariant and contravariant in a,
preventing implementing either fmap or contramap
then
(a->a) -> f a
too cannot be a NT
it is, however, a "dinatural transformation"

